# java基础教程总结

## 疑问点

* 方法引用（方法）
* 局部内部类（特殊的局部内部类匿名内部类）变量

## java内存模型

* 分析如下代码

  ```java
  public Class Dog {
      private String name ;
      private String sex;
      public dogWangWangWang() {
          Sout（“hello”）
      }
      psvm{
          Dog dog =new Dog();
          dog.setName("xiaogou");
          dog.dogWangWangWang();    }
  }
  ```

  上述main方法中主要进行了如下操作

  * 首先class的信息存放在方法区
  * 第一步main方法入栈new对象时，在堆中复制一份类信息的拷贝，初始化对象信息成员变量付默认值，方法中存的是方法区方法的地址
  * 第二个赋值name就是给成员变量的默认值改成想要的值
  * 第三个就是在调用方法的是汪汪汪方法入栈，调用汪汪汪方法结束后进行出栈操作 


## 内部类

* 内部类特点

  * 可以直接访问外部类的成员，包括私有
  * 外部类访问内部类必须创建对象
  * 外部类名.内部类名 对象名 = 外部对象.内部对象

* 成员内部类私有使用

  

* 静态内部类

  调用非静态 外部类名.内部类名 对象名 = 外部类名.内部对象

  调用静态  外部类名.内部类名.静态方法

* 成员内部类

  

* 局部内部类方法局部变量

  局部内部可只能在其所在的方法中访问

  局部内部类在访问他所在方法中的局部变量必须用final修饰,为什么?
  因为当调用这个方法时,局部变量如果没有用final修饰,他的生命周期和方法的生命周期是一样的,当方法弹栈,这个局部变量也会消失,那么如果局部内部类对象还没有马上消失想用这个局部变量,就没有了,如果用final修饰会在类加载的时候进入常量池,即使方法弹栈,常量池的常量还在,也可以继续使用

  但是jdk1.8取消了这个事情,所以我认为这是个bug,虽然取消,如果在书写代码时候,没有手动添加,系统底层也会默给你final

* 匿名内部类

  * 本质上就是内部类的简化写法
  * 前提存在一个类或者接口
    * 这里的类可以是具体类也可以是抽象类

* 